/returns_null.kt:(121,140): info: Generated Viper text for simple_returns_null:
domain dom$Unit  {

  function dom$Unit$element(): dom$Unit
}

domain dom$Nullable[T]  {

  function dom$Nullable$null(): dom$Nullable[T]

  function dom$Nullable$nullable_of(x: T): dom$Nullable[T]

  function dom$Nullable$val_of(x: dom$Nullable[T]): T

  axiom dom$Nullable$some_not_null {
    (forall x: T ::
      { (dom$Nullable$nullable_of(x): dom$Nullable[T]) }
      (dom$Nullable$nullable_of(x): dom$Nullable[T]) !=
      (dom$Nullable$null(): dom$Nullable[T]))
  }

  axiom dom$Nullable$val_of_nullable_of_val {
    (forall x: T ::
      { (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) }
      (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) ==
      x)
  }

  axiom dom$Nullable$nullable_of_val_of_nullable {
    (forall x: dom$Nullable[T] ::
      { (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) }
      x != (dom$Nullable$null(): dom$Nullable[T]) ==>
      (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) ==
      x)
  }
}

method global$pkg_$simple_returns_null(local$x: dom$Nullable[Int])
  returns (ret$: dom$Nullable[Int])
  ensures ret$ == (dom$Nullable$null(): dom$Nullable[Int])
  ensures ret$ != (dom$Nullable$null(): dom$Nullable[Int]) ==> true
{
  ret$ := (dom$Nullable$null(): dom$Nullable[Int])
}

/returns_null.kt:(299,319): info: Generated Viper text for returns_null_implies:
domain dom$Unit  {

  function dom$Unit$element(): dom$Unit
}

domain dom$Nullable[T]  {

  function dom$Nullable$null(): dom$Nullable[T]

  function dom$Nullable$nullable_of(x: T): dom$Nullable[T]

  function dom$Nullable$val_of(x: dom$Nullable[T]): T

  axiom dom$Nullable$some_not_null {
    (forall x: T ::
      { (dom$Nullable$nullable_of(x): dom$Nullable[T]) }
      (dom$Nullable$nullable_of(x): dom$Nullable[T]) !=
      (dom$Nullable$null(): dom$Nullable[T]))
  }

  axiom dom$Nullable$val_of_nullable_of_val {
    (forall x: T ::
      { (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) }
      (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) ==
      x)
  }

  axiom dom$Nullable$nullable_of_val_of_nullable {
    (forall x: dom$Nullable[T] ::
      { (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) }
      x != (dom$Nullable$null(): dom$Nullable[T]) ==>
      (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) ==
      x)
  }
}

method global$pkg_$returns_null_implies(local$x: dom$Nullable[Int])
  returns (ret$: dom$Nullable[Int])
  ensures ret$ == (dom$Nullable$null(): dom$Nullable[Int]) ==>
    local$x == (dom$Nullable$null(): dom$Nullable[Int])
  ensures ret$ != (dom$Nullable$null(): dom$Nullable[Int]) ==>
    local$x != (dom$Nullable$null(): dom$Nullable[Int])
{
  ret$ := local$x
}

/returns_null.kt:(502,522): info: Generated Viper text for returns_null_with_if:
domain dom$Unit  {

  function dom$Unit$element(): dom$Unit
}

domain dom$Nullable[T]  {

  function dom$Nullable$null(): dom$Nullable[T]

  function dom$Nullable$nullable_of(x: T): dom$Nullable[T]

  function dom$Nullable$val_of(x: dom$Nullable[T]): T

  axiom dom$Nullable$some_not_null {
    (forall x: T ::
      { (dom$Nullable$nullable_of(x): dom$Nullable[T]) }
      (dom$Nullable$nullable_of(x): dom$Nullable[T]) !=
      (dom$Nullable$null(): dom$Nullable[T]))
  }

  axiom dom$Nullable$val_of_nullable_of_val {
    (forall x: T ::
      { (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) }
      (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) ==
      x)
  }

  axiom dom$Nullable$nullable_of_val_of_nullable {
    (forall x: dom$Nullable[T] ::
      { (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) }
      x != (dom$Nullable$null(): dom$Nullable[T]) ==>
      (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) ==
      x)
  }
}

method global$pkg_$returns_null_with_if(local$x: dom$Nullable[Int], local$y: dom$Nullable[Int],
  local$z: dom$Nullable[Int])
  returns (ret$: dom$Nullable[Int])
  ensures ret$ == (dom$Nullable$null(): dom$Nullable[Int]) ==>
    local$x == (dom$Nullable$null(): dom$Nullable[Int]) &&
    local$y == (dom$Nullable$null(): dom$Nullable[Int]) ||
    local$z == (dom$Nullable$null(): dom$Nullable[Int])
  ensures ret$ != (dom$Nullable$null(): dom$Nullable[Int]) ==>
    local$x != (dom$Nullable$null(): dom$Nullable[Int]) ||
    local$y != (dom$Nullable$null(): dom$Nullable[Int])
{
  var anonymous$1: dom$Unit
  if (local$x == (dom$Nullable$null(): dom$Nullable[Int])) {
    ret$ := local$y
    anonymous$1 := dom$Unit$element()
  } else {
    ret$ := local$z
    anonymous$1 := dom$Unit$element()
  }
}
